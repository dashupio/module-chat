<page-chat-view>
  <div class="d-flex flex-column flex-1">
    <div class="row g-0 flex-1">

      <!-- CHAT LIST -->
      <div class="col chat-column mb-4 mb-lg-0">
        <div class="column-body">
          <div class="column-body-inner">
            <div class="card">
              <div class="card-body task-container">
                <page-chat-task each={ (item, i) in state.items } item={ item } page={ props.page } form-fields={ state.fields } add-user={ onAddUser } add-tag={ onAddTag } on-item={ (e) => props.onItem(e, item) } on-click={ (e) => state.item && state.item.get('_id') === item.get('_id') ? props.onItem(e, item) : onClick(e, item) } class={ classes({ 'd-none' : !isVisible(item), 'active' : state.item && state.item.get('_id') === item.get('_id') }) } />
              </div>
            </div>
          </div>
        </div>
      </div>
      <!-- / CHAT LIST -->

      <!-- CHAT BODY -->
      <div class="col ml-3 d-flex flex-column" if={ loading('chat') }>
        <div class="mx-auto my-5">
          <i class="fa fa-spinner fa-spin h1" />
        </div>
      </div>
      <!-- / CHAT BODY -->

      <!-- CHAT MAIN -->
      <div class="col ml-3 d-flex flex-column" if={ !loading('chat') && state.item }>
        <dashup-view type="page" struct="channel" view="chat" class="d-flex flex-1" dashup={ props.dashup } page={ props.page } item={ state.item } />
      </div>
      <!-- / CHAT MAIN -->
    </div>

    <!-- TAGS -->
    <div class="dropdown-menu show m-0 p-0" if={ state.model && state.menu === 'tag' } aria-labelledby={ `tag-${state.model.get('_id')}` } id={ `tag-dd-${state.model.get('_id')}` }>
      <dashup-tag ref={ ref('model') } { ...props } />
    </div>
    <div class="dropdown-menu show m-0 p-0" if={ state.model && state.menu === 'user' } aria-labelledby={ `user-${state.model.get('_id')}` } id={ `user-dd-${state.model.get('_id')}` }>
      <dashup-user ref={ ref('model') } { ...props } />
    </div>
    <!-- / TAGS -->
  </div>

  <script>
    // perfect
    import PerfectScrollbar from 'perfect-scrollbar';

    // chat page task
    import pageChatTask from './task.riot';

    // export default
    export default class PageChatView {


      // ////////////////////////////////////////////////////////////////////////////
      //
      // RIOT METHODS
      //
      // ////////////////////////////////////////////////////////////////////////////

      /**
       * local components
       */
      static get components() {
        // return components
        return {
          pageChatTask,
        };
      }

      /**
       * on before mount
       */
      onBeforeMount(...args) {
        // check frontend
        if (typeof window === 'undefined') return;

        // safe update
        this.safeUpdate = () => {
          this.update();
        };

        // fields
        this.state.fields = this.getFields();
        
        // bind
        this.init    = this.init.bind(this);
        this.onClick = this.onClick.bind(this);

        // listeners
        this.props.page.on('reload', this.safeUpdate);
        this.props.page.on('data.form', this.safeUpdate);
      }
      
      /**
       * on mounted
       *
       * @param {Array} args
       */
      onBeforeUpdate(...args) {
        // check window
        if (typeof window === 'undefined') return;

        // fields
        this.state.fields = this.getFields();
      }
      
      /**
       * on mounted
       *
       * @param {Array} args
       */
      onMounted(...args) {
        // check window
        if (typeof window === 'undefined') return;

        // fields
        this.state.fields = this.getFields();
        
        // init
        this.init();
      }
      
      /**
       * on mounted
       *
       * @param {Array} args
       */
      onUpdated(...args) {
        // check window
        if (typeof window === 'undefined') return;
        
        // set ps
        if (!this.$('.task-container.ps') && this.$('.task-container')) {
          // perfect scrollbar
          this.ps = new PerfectScrollbar(this.$('.task-container'), {
            suppressScrollX : true,
          });
        }
      }

      /**
       * on before mount
       */
      onBeforeUnmount(...args) {
        // check frontend
        if (typeof window === 'undefined') return;

        // listeners
        this.props.page.removeListener('reload', this.safeUpdate);
        this.props.page.removeListener('data.form', this.safeUpdate);
      }


      // ////////////////////////////////////////////////////////////////////////////
      //
      // GET METHODS
      //
      // ////////////////////////////////////////////////////////////////////////////

      /**
       * get props
       */
      getProps() {
        // clone
        const newProps = { ...(this.props) };

        // delete
        delete newProps.type;
        delete newProps.view;
        delete newProps.class;
        delete newProps.struct;

        // return
        return newProps;
      }

      /**
       * get fields
       */
      getFields() {
        // reduce
        return [this.props.page.get('data.form')].reduce((accum, form) => {
          // check form
          if (!form) return accum;

          // get form
          const actualForm = this.props.dashup.page(form);

          // check fields
          if (!actualForm || !actualForm.get('data.fields')) return [];

          // return data
          accum.push(...(actualForm.get('data.fields').map((field) => {
            // clone field
            const newField = { ...field };

            // set form
            newField.form = form;

            // new field
            return newField;
          })));

          // return accum
          return accum;
        }, []);
      }
      
      /**
       * is filter me
       */
      isFilter(type, val) {
        // check me
        return ((this.props.page.get('user.filter') || {})[type] || false) === val;
      }

      /**
       * check visible
       */
      isVisible(task) {
        // tags
        const tags = this.props.search && this.props.search.length ? this.props.search.toLowerCase().split(' ') : [];

        // check filter
        if (this.isFilter('me', true)) {
          // check vals
          const userField = this.state.fields.find((f) => f.uuid === this.props.page.get('data.user'));

          // get vals
          let vals = task.get(userField ? userField.name || userField.uuid : 'null') || [];

          // vals
          if (vals && !Array.isArray(vals)) vals = [vals];

          // only me
          if (!vals.find((val) => {
            // user
            return val.user === this.props.me.get('id');
          })) return false;
        }

        // check tags
        if ((this.props.page.get('user.filter.tags') || []).length) {
          // check vals
          const tagField = this.state.fields.find((f) => f.uuid === this.props.page.get('data.tag'));

          // check filter
          if (this.props.page.get('user.filter.tags').find((tag) => {
            // check tag exists on task
            let val = task.get(tagField ? tagField.name || tagField.uuid : 'null') || [];

            // set value
            if (typeof val === 'string') val = [val];

            // check tag
            return !val.includes(tag);
          })) return false;
        }

        // filter
        if (tags.length) {
          // search item
          const searchable = JSON.stringify(task.get()).toLowerCase();

          // search JSON
          if (tags.find((tag) => {
            // check
            return !searchable.includes(tag);
          })) return false;
        }

        // return true
        return true;
      }


      // ////////////////////////////////////////////////////////////////////////////
      //
      // EVENT METHODS
      //
      // ////////////////////////////////////////////////////////////////////////////

      /**
       * on click
       */
      onClick(e, item) {
        // prevent default
        e.preventDefault();
        e.stopPropagation();
  
        // loading chat
        this.loading('chat', true);

        // update state
        this.update({
          item,
        });

        // timeout fix
        setTimeout(() => this.loading('chat', false), 10);
      }


      // ////////////////////////////////////////////////////////////////////////////
      //
      // Init Methods
      //
      // ////////////////////////////////////////////////////////////////////////////
  
      /**
       * init
       */
      async init() {
        // items
        if (this.state.items && this.state.items.removeListener) {
          // safe update
          this.state.items.removeListener('update', this.safeUpdate);
        }

        // get model
        let items = [];
        const model = this.props.page.get('data.model');

        // query by
        if (model) {
          // set query
          let query = this.props.dashup.page(model).sort('updated_at', -1);

          // check items
          if (this.props.page.get('data.form')) {
            // loop forms
            query = query.where({
              '_meta.form' : this.props.page.get('data.form')
            });
          }

          // load filter
          let filter = null;

          // try/catch
          try {
            filter = JSON.parse(this.props.page.get('data.filter'));
          } catch (e) {}
  
          // add initial where
          if (filter) {
            // add wheres
            filter.forEach((where) => {
              // where
              query = query.where(where);
            });
          }

          // check where
          (this.props.page.get('user.where') || []).forEach((where) => {
            // add query
            query = query[where[0]](where[1], where[2]);
          });

          // listen
          items = await query.listen();
        }

        // update
        this.update({
          items,
        });

        // safe update
        if (items && items.on) items.on('update', this.safeUpdate);
      }


      // ////////////////////////////////////////////////////////////////////////////
      //
      // MISC METHODS
      //
      // ////////////////////////////////////////////////////////////////////////////

      /**
       * ref
       */
      ref(name) {
        // set refs
        if (!this.refs) this.refs = {};

        // return ref function
        return (that) => {
          // set ref
          this.refs[name] = that;
        };
      }

      /**
       * classes
       */
      classes(obj) {
        // return object
        return Object.keys(obj).filter((k) => obj[k]).join(' ');
      }

      /**
       * set loading
       */
      loading(type, way) {
        // set loading
        if (!this.__loading) this.__loading = new Map();

        // check loading
        if (!type) return !!Array.from(this.__loading.values()).find((v) => v);
        if (typeof way === 'undefined') return !!this.__loading.get(type);

        // set loading
        this.__loading.set(type, way);
        this.update();
      }
    }
  </script>
</page-chat-view>