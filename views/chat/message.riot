<chat-message>
  <div if={ !props.message.removed } class={ classes({ 'message dropdown' : true, 'in-thread' : inThread() }) }>
    <div class="message-avatar">
      <img if={ get('message.by.avatar') } src={ get('message.by.avatar') } class="rounded-circle img-fluid" />
    </div>
    <div class="message-body">
      <div class="message-by">
        <b class="mr-1" if={ get('message.by.name') }>
          { get('message.by.name') }
        </b>
        <small class="text-muted">
          { getDate(get('message.created_at')) }
        </small>
      </div>
      <div class="message-content">
        <raw data={ { html : renderText(get('message.parsed') || get('message.message')) } } />
      </div>
      <div if={ getEmbeds().length } class="mb-2 message-embeds">
        <div each={ (embed, i) in getEmbeds() } class="mt-2 card">
          <div class="card-body">
            <chat-embed in-message={ true } embed={ embed } class="embed-child" />
          </div>
        </div>
      </div>
    </div>
    <div class="message-settings">
      <div class="btn-group">
        <button class="btn btn-sm btn-secondary" data-toggle="dropdown" if={ isMine() }>
          <i class="fa fa-ellipsis-h" />
        </button>
        <div class="dropdown-menu dropdown-menu-right">
          <button class="dropdown-item text-danger" onclick={ (e) => onRemove(e) }>
            <i class="fa fa-trash mr-2" />
            Remove Message
          </button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // require base class
    import moment from 'moment';
    import dotProp from 'dot-prop';
    import { v4 as uuid } from 'uuid';

    // chat embed
    import chatEmbed from './embed';

    // export default
    export default class ChatMessage {


      // ////////////////////////////////////////////////////////////////////////////
      //
      // RIOT METHODS
      //
      // ////////////////////////////////////////////////////////////////////////////

      /**
       * get components
       */
      static get components() {
        // return object
        return {
          chatEmbed,
        };
      }

      /**
       * on before unmount
       */
      onBeforeMount() {
        // bind
        this.onClick = this.onClick.bind(this);
      }

      /**
       * on before unmount
       */
      onBeforeUnmount() {
        // remove lisetener
        $(document).off('click', this.onClick);
      }

      /**
       * in thread
       */
      inThread() {
        // return in thread
        return this.get('message.by.id') === this.get('prev.by.id');
      }

      /**
       * is mine
       */
      isMine() {
        // check mine
        return `${(this.props.message.by || {}).id}` === `${eden.get('user').get('_id')}`;
      }
      
      /**
      * get date
      *
      * @param  {Date} created_at
      *
      * @return {String}
      */
      getDate(date) {
        // from now
        return moment(date).fromNow(true);
      }

      /**
       * get embeds
       */
      getEmbeds() {
        // return embeds
        return (this.get('message.embeds') || []).filter((e) => e && e.data && e.data.type);
      }

      /**
      * parse tags out of message text
      *
      * @param  {String} text
      *
      * @return {Array}
      */
      renderText(text) {
        // add placeholders
        const tags = ((text || '').match(/<(\w+):(.*?)\|(\w+)>/g) || []).map((val) => {
          // replace tag
          const tag = val.replace('<', '').replace('>', '');

          // return tag
          const parsed = {
            id    : tag.split('|')[1].trim(),
            type  : tag.split(':')[0].trim(),
            text  : val,
            uuid  : uuid(),
            page  : tag.split(':')[0].trim() === 'page' ? this.props.dashup.page(tag.split('|')[1].trim()) : null,
            title : tag.split(':')[1].split('|')[0].trim(),
          };

          // return tag
          return parsed;
        });

        // colors
        const colors = {
          user : 'primary',
        };

        // loop tags
        tags.forEach((tag) => {
          // check user
          if (tag.type === 'user') {
            // join tags
            text = text.split(tag.text).join(`<span class="badge badge-${colors[tag.type]} badge-tag"><i class="fa fa-at"></i><span class="content">${tag.title}</span></span>`);
          }
          if (tag.type === 'page' && tag.page) {
            // get parent
            const parent = tag.page.get('parent') && this.props.dashup.page(tag.page.get('parent'));

            // join tags
            text = text.split(tag.text).join(`<a href="/app/${tag.page.get('_id')}" class="badge badge-${tag.page.get('color') || (parent && parent.get('color')) || 'secondary'} badge-tag"><i class="fa-${tag.page.get('icon') || 'pencil fa'}"></i><span class="content">${tag.page.get('name')}</span></a>`);
          }
        });

        // return text
        return text;
      }

      /**
       * on click
       */
      onClick(e) {
        // on click
        if (!$(e.target).is('.dropdown-menu') && !$(e.target).closest('.dropdown-menu').length) {
          // hide
          $(this.$('.message')).dropdown('hide');
          $(document).off('click', this.onClick);
        }
      }
      
      /**
       * on remove message
       */
      onRemove(e) {
        // prevent default
        e.preventDefault();
        e.stopPropagation();

        // removed
        this.props.message.removed = true;
        this.update();
        
        // call join
        this.props.dashup.action({
          type   : 'page',
          struct : 'channel',
        }, 'remove', this.props.subject, this.props.message.id);
      }


      // ////////////////////////////////////////////////////////////////////////////
      //
      // MISC METHODS
      //
      // ////////////////////////////////////////////////////////////////////////////

      /**
       * ref
       */
      ref(name) {
        // set refs
        if (!this.refs) this.refs = {};

        // return ref function
        return (that) => {
          // set ref
          this.refs[name] = that;
        };
      }

      /**
       * ref
       */
      get(key) {
        // get
        return dotProp.get({ ...this.props, ...this.state }, key);
      }

      /**
       * classes
       */
      classes(obj) {
        // return object
        return Object.keys(obj).filter((k) => obj[k]).join(' ');
      }

      /**
       * set loading
       */
      loading(type, way) {
        // set loading
        if (!this.__loading) this.__loading = new Map();

        // check loading
        if (!type) return !!Array.from(this.__loading.values()).find((v) => v);
        if (typeof way === 'undefined') return !!this.__loading.get(type);

        // set loading
        this.__loading.set(type, way);
        this.update();
      }
    }
  </script>

  <style>
    .message {
      position      : relative;
      border-radius : .25rem;
    }
    .message:hover {
      background : var(--bs-secondary-transparent);
    }
    .message > .message-settings {
      top      : -.5rem;
      right    : .5rem;
      position : absolute;
    }
    .message > .message-settings > .btn-group {
      opacity : 0;
    }
    .message:hover > .message-settings > .btn-group {
      opacity : 1;
    }
  </style>
</chat-message>